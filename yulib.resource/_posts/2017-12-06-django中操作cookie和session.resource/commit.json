{"compress":true,"commitItems":[["36eb9f2a-82e6-4c51-90fa-5fc216b39d9e",1512556497085,"",[[1512556470205,["qiumeng@bogon",[[1,0,"---\nlayout: post\ntitle:  \"3 Steps (2 minutes) to Setup Your Personal Website with Jalpc\"\ndate:   2017-01-31\ndesc: \"3 Steps (2 minutes) to Setup Your Personal Website with Jalpc\"\nkeywords: \"Jalpc,Jekyll,gh-pages,website,blog,easy\"\ncategories: [HTML]\ntags: [Jalpc,Jekyll]\nicon: icon-html\n---"]],[0,0],[289,289]]],[1512556487389,["qiumeng@bogon",[[-1,26,"3 Steps (2 minutes) to Setup Your Personal Website with Jalpc"],[1,87,"django cookie&session"]],[26,87],[47,47]]],[1512556489471,["qiumeng@bogon",[[-1,32," "]],[33,33],[32,32]]],[1512556490798,["qiumeng@bogon",[[1,32,"操作"]],[32,32],[34,34]]],[1512556493139,["qiumeng@bogon",[[1,32,"中"]],[32,32],[33,33]]],[1512556515301,["qiumeng@bogon",[[-1,77,"3 Steps (2 minutes) to Setup Your Personal Website with Jalpc"]],[77,138],[77,77]]],[1512556519056,["qiumeng@bogon",[[1,77,"django中操作cookie&session"]],[77,77],[100,100]]],[1512556522348,["qiumeng@bogon",[[-1,64,"01"]],[66,66],[64,64]]],[1512556522594,["qiumeng@bogon",[[1,64,"12"]],[64,64],[66,66]]],[1512556523680,["qiumeng@bogon",[[-1,67,"31"]],[69,69],[67,67]]],[1512556524790,["qiumeng@bogon",[[1,67,"06"]],[67,67],[69,69]]],[1512556529915,["qiumeng@bogon",[[-1,113,"Jalpc"],[1,118,"d"]],[113,118],[113,114]]],[1512556530042,["qiumeng@bogon",[[1,114,"'j"]],[113,114],[113,116]]],[1512556530163,["qiumeng@bogon",[[-1,114,"'"],[1,116,"a"]],[113,116],[113,116]]],[1512556530226,["qiumeng@bogon",[[1,116,"n"]],[113,116],[113,117]]],[1512556530346,["qiumeng@bogon",[[1,117,"g"]],[113,117],[113,118]]],[1512556530561,["qiumeng@bogon",[[1,118,"o"]],[113,118],[113,119]]],[1512556531668,["qiumeng@bogon",[[-1,113,"d"],[1,114,"D"]],[113,119],[119,119]]],[1512556533643,["qiumeng@bogon",[[-1,120,"Jekyll"],[1,126,"s"]],[120,126],[120,121]]],[1512556533845,["qiumeng@bogon",[[1,121,"e"]],[120,121],[120,122]]],[1512556534171,["qiumeng@bogon",[[1,122,"'s"]],[120,122],[120,124]]],[1512556534297,["qiumeng@bogon",[[-1,122,"'"],[1,123,"s"]],[120,124],[120,124]]],[1512556534976,["qiumeng@bogon",[[1,124,"ion"]],[120,124],[127,127]]],[1512556537476,["qiumeng@bogon",[[-1,128,"gh-pages"]],[131,136],[128,128]]],[1512556539080,["qiumeng@bogon",[[1,128,"cookie"]],[128,128],[134,134]]],[1512556541257,["qiumeng@bogon",[[-1,135,"website"],[1,142,"p"]],[135,142],[135,136]]],[1512556541533,["qiumeng@bogon",[[1,136,"'y"]],[135,136],[135,138]]],[1512556541650,["qiumeng@bogon",[[1,138,"'t"]],[135,138],[135,140]]],[1512556541794,["qiumeng@bogon",[[-1,136,"'"],[-1,138,"'"],[1,140,"h"]],[135,140],[135,139]]],[1512556541985,["qiumeng@bogon",[[1,139,"o"]],[135,139],[135,140]]],[1512556542192,["qiumeng@bogon",[[1,140,"n"]],[135,140],[135,141]]],[1512556542822,["qiumeng@bogon",[[-1,135,"p"],[1,136,"P"]],[135,141],[141,141]]],[1512556545864,["qiumeng@bogon",[[-1,142,"blog,easy"]],[142,151],[142,142]]],[1512556547983,["qiumeng@bogon",[[1,142,"blog,easy"]],[142,142],[142,151]]],[1512556548350,["qiumeng@bogon",[[1,135,"p"],[-1,135,"P"]],[141,141],[135,141]]],[1512556551374,["qiumeng@bogon",[[-1,141,",blog,easy"]],[141,151],[141,141]]],[1512556552791,["qiumeng@bogon",[[-1,135,"p"]],[136,136],[135,135]]],[1512556553733,["qiumeng@bogon",[[1,135,"P"]],[135,135],[136,136]]],[1512556563168,["qiumeng@bogon",[[-1,169,"Jalpc"],[1,174,"Django"]],[169,174],[175,175]]],[1512556575776,["qiumeng@bogon",[[-1,176,"Jekyll"],[1,182,"Python,SESSIOn"]],[176,182],[190,190]]],[1512556576661,["qiumeng@bogon",[[-1,189,"n"]],[190,190],[189,189]]],[1512556581323,["qiumeng@bogon",[[1,189,"N,COOKIE"]],[189,189],[197,197]]],[1512556589856,["qiumeng@bogon",[[1,218,"\n\n## cookie\n\n----\n\n#### cookie是什么\n由于http协议是无状态的，即服务器不知道用户的上一步操作是干了什么。这严重阻碍了`交互式WEB应用程序`的实现。cookie是http的一个额外的手段，用来保存用户的一部分信息到用户端，即cookie使保存在用户端的，由用户的浏览器来维护，通常被分为两种类型：内存cookie、硬盘cookie。cookie被夹带在http请求中，一般大小限制在4KB左右\n\n服务器在响应中添加设置过cookie后，支持cookie的浏览器都会做出反应，来使用某种方式来保存这个cookie，当用户下次再次发出请求的时候，浏览器判断当前cookie是否失效（expirse）、匹配路径（path）、匹配域名(domain)等操作后，将这段cookie加入到请求头中发送到服务器端。服务端对其进行处理\n\n#### 在django中使用cookie\n+ **实现保存用户登录状态**\n```python\n# views.py\ndef login(request):\n    if request.method == \"GET\":\n        return render(request, 'login.html')\n    elif request.method == \"POST\":\n        u = request.POST.get(\"username\", None)\n        p = request.POST.get(\"password\", None)\n        dic = user_info.get(u)\n        print(dic)\n        if not dic:\n            return render(request, 'login.html')\n        elif dic.get('pwd') == p:\n           # 密码正确后设定cookie\n            response = redirect('/index/')\n            response.set_cookie(\"username\", u)\n            return response\n        else:\n            return render(request, 'login.html')\n    else:\n        return render(request, 'login.html')\n\n#index\ndef index(request):\n    ck = request.COOKIES.get(\"username\")  # 早cookie中获取当前登录的用户\n    if not ck:\n         return redirect('/login/')\n    return render(request, 'index.html', {'current_user': ck})\n```\n当用户名和密码验证成功后，在返回的`redirect`中设定`cookie`。通过这种简单的例子即可以实现保存用户的登录状态，当用户下一次访问index的时候就不在需要登录\n\n+ **cookie的一些其他设定：**\n\n1.`request.COOKIES` 用户发来数据中带来的COOKIE，为一个字典，可以使用get来获取\n2.`response.set_cookie(\"字典的key\"，'字典的值')` 后面不加参数的时候，只能设置一个当浏览器关闭就失效的cookie\n3.`response.set_cookie(\"username\",'value',max_age=10)`  多少秒后过期的cookie\n4.通过datetime来设定过期\n```python\ncurrent_date = datetime.datetime.utcnow()\ncurrent_date = current_date+ datetime.timedelta(seconds=10)   # 当前时间加上10s后\nresponse.set_cookie(\"username\", u, expires=current_date)  # 设定到哪个时间点后失效，如果时间设置与当前时间相同，那么就是清除这个cookie\n```\n 5.设定cookie作用的路径\n```\nresponse.set_cookie(\"username\", u,path='/index/')  # 设置这个cookie只在当前url生效，例如设定一个cookie为当前页面显示多少条数据，别的页面就不会被干扰\n```\n6.`domain=''`  为当前设置cookie的域名\n7.`secure = False` 为https传输设置cookie\n8.`httponly = True` 设置cookie只做为http传输，不可以被js获取到。在js中使用`document.cookie`获取可以所有cookie，或者使用JQuery也可以操作cookie\n\n9.带salt的cookie\n```\n# 设定加盐\nCOOKIE_SALT = \"随机字符串\"\nresponse.set_signed_cookie('username', u, salt=COOKIE_SALT)\n\n# 加盐获取\nck = request.get_singed_cookie(\"username\",salt=COOKIE_SALT)\n```\n\n----\n\n## session\n\n\n#### session是什么 \n[参考：晋哥哥的私房钱](http://www.cnblogs.com/shoru/archive/2010/02/19/1669395.html)\n\nsession一般被译为会话，从不同的角度上来看到会话，是有不同的意义的：\n\n1.  从用户的角度来看，他打开一个网站，并进行了一系列的浏览、登录、购物等操作，这就可以被称为一个会话\n2. 从底层来细细分析呢，由于http的无状态性，用户登录我们需要保存他的登录状态，当前购物车中的所有商品都需要保存下来，所以我们需要一个特定的数据结构来保存这些数据。这个东西就被称为session\n\n所以session是一种基于http协议的用于增强http的一种数据存储结构或方案，session存储在服务端。服务端创建session的一般步骤分为：生成一个全局唯一标识`sessionid`，在对应的数据中开辟存储空间，然后将session的全局唯一标识符发送到客户端。 服务端为每一个session维护一份会话信息数据，而客户端和服务端依靠一个全局唯一的标识来访问会话信息数据。\n\n那么客户端和服务端怎么发送这个标识符呢？一般实现有两种方式：\n\n+ cookie，服务端通过设定cookie的方式，将sessionid发送到客户端\n![](/content/images/2017/11/QQ20171107-152411.png)\n+ url重写，在返回用户请求的页面之前，将页面内所有的URL后面全部以get的方式加上session标识符，用户在下次操作上，都会加上这个标识符，从而实现了会话保持，这也是当用户禁用cookie的做有效的办法\n\n\n#### cookie与session的对比\n1.   应用场景\n\n  + Cookie的典型应用场景是记住密码、记住我操作，用户的账户信息通过cookie的形式保存在客户端，当用户再次请求匹配的URL的时候，账户信息会被传送到服务端，交由相应的程序完成自动登录等功能。当然也可以保存一些客户端信息，比如页面布局以及搜索历史等等。\n  + Session的典型应用场景是用户登录某网站之后，将其登录信息放入session，在以后的每次请求中查询相应的登录信息以确保该用户合法。当然还是有购物车等等经典场景；\n2.   安全性\n  + cookie将信息保存在客户端，如果不进行加密的话，无疑会暴露一些隐私信息，安全性很差，一般情况下敏感信息是经过加密后存储在cookie中，但很容易就会被窃取。\n  + session只会将信息存储在服务端，如果存储在文件或数据库中，也有被窃取的可能，只是可能性比cookie小了太多。这里涉及到的是硬件安全，但是总体来说session的安全性要高于cookie；\n3.   性能\n  + Cookie存储在客户端，消耗的是客户端的I/O和内存，而session存储在服务端，消耗的是服务端的资源。\n  + session对服务器造成的压力比较集中，而cookie很好地分散了资源消耗，就这点来说，cookie是要优于session的；\n4.   时效性\n  + Cookie可以通过设置有效期使其较长时间内存在于客户端，而\n  + session一般只有比较短的有效期（用户主动销毁session或关闭浏览器后引发超时）；\n5.   其他\nCookie的处理在开发中没有session方便。而且cookie在客户端是有数量和大小的限制的，而session的大小却只以硬件为限制，能存储的数据无疑大了太多。\n\n#### django中使用session\n\n\n注：\n\n1. django默认使用`django.contrib.sessions.models.Session`模块，将session存储在数据库的`django_session `表中，当然这些都是可以配置的\n\n2. 所以需要在使用`database-backed sessions`前进行一定的设定，在数据库当中生成存储session的表以及字段\n```shell\npython manage.py makemigrations\npython manage.py migrate\n```\n\n\n+ **简单实现**\n```\n# views.py\ndef login(request):\n    if request.method == \"GET\":\n        return render(request, \"login.html\")\n\n    if request.method == \"POST\":\n        user = request.POST.get('user')\n        pwd = request.POST.get('pwd')\n        rmb = request.POST.get('rmb',None)\n        print(rmb)\n        if user == 'root' and pwd == \"123\":\n            # 直接设定值\n            request.session['username'] = user\n            request.session['is_login'] = True\n            if rmb == \"10\":\n                request.session.set_expiry(10)  # 设置多少秒后过期\n            # 生成的session默认存储在django的默认数据库中\n            return redirect('/index/')\n        else:\n            return render(request, \"login.html\")\n\ndef logout(request):\n    # 注销\n    if request.method == 'POST':\n        print(request.session.get('username'))\n        request.session.delete(request.session.session_key) # 从数据库中删除\n        print(request.session.session_key)\n        print(request.session.get('username'))\n        return redirect('/login/')\n\ndef index(request):\n    if request.session.get('is_login'):\n        return render(request, 'index.html')\n    else:\n        return HttpResponse(\"Fuck off\")\n```\n+ 在这样的应用中访问会在数据库中生成以下数据\n\n![session-table](/content/images/2017/11/session-table.png)\n\n+ **更多操作**\n  \n```\n1. 获取session中的值\nrequest.session['k1']\nrequest.session.get('k1',None)\n2. 设定session中的值\nrequest.session['k1'] = 123\nrequest.session.setdefault('k1',123) # 存在则不设置\n3. 删除session对应的值\ndel request.session['k1']\n4. 由于session的真是数据结构其实是个字典对象，所以拥有字典的一些方法：\nrequest.session.keys() # 所有的key\nrequest.session.values() # 所有的value\nrequest.session.items() # 键值对元组\n# 其他方法\nrequest.session.iterkeys() # key的可迭代对象\nrequest.session.itervalues() # value的可迭代对象\nrequest.session.iteritems()  # 键值对元组的可迭代对象\n5. 用户的全局唯一sessionid\nrequest.session.session_key\n6. 将所有Session失效日期小于当前日期的数据删除\nrequest.session.clear_expired()\n7. 判断是否存在\nrequest.session.exists(\"session_key\")\n8. 删除这个sessionid，并也会删除其对应的数据\nrequest.session.delete(\"session_key\")\n9. 过期设定\nrequest.session.set_expiry(value)\n    * 如果value是个整数，session会在些秒数后失效。\n    * 如果value是个datatime或timedelta，session就会在这个时间后失效\n    * 如果value是0,用户关闭浏览器session就会失效。\n    * 如果value是None,session会依赖全局session失效策略。（默认是两个周）\n```\n+ **配置相关**\n\n1.引擎相关\n除了django自己支持的以下几种引擎以外，还可以使用redis作为session的存储，可以参考redis的设置方法    [猛戳](http://django-redis-chs.readthedocs.io/zh_CN/latest/#cache-backend)\n```python\n# 数据库存储\nSESSION_ENGINE = 'django.contrib.sessions.backends.db'\n# 缓存存储\nSESSION_ENGINE = 'django.contrib.sessions.backends.cache'\n# 文件存储\nSESSION_ENGINE = 'django.contrib.sessions.backends.file'\nSESSION_FILE_PATH = None # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir()\n# 缓存加数据库\nSESSION_ENGINE = 'django.contrib.sessions.backends.cached_db'\n# 加密cookie Session\nSESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies'\n```\n\n2.通用设定\n\n```\nSESSION_COOKIE_NAME ＝ \"sessionid\" # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串\nSESSION_COOKIE_PATH ＝ \"/\"  # Session的cookie保存的路径\nSESSION_COOKIE_DOMAIN = None  # Session的cookie保存的域名\nSESSION_COOKIE_SECURE = False  # 是否Https传输cookie\nSESSION_COOKIE_HTTPONLY = True  # 是否Session的cookie只支持http传输\nSESSION_COOKIE_AGE = 1209600  # Session的cookie失效日期（2周）\nSESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期\nSESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存\n```\n\n\n"]],[218,218],[7599,7599]]]]]]}